<%- include('partials/header') %>


  <div class="jumbotron centered">
    <div class="container">
      <em class="fas fa-key fa-6x"></em>
      <h1 class="display-3">Secrets</h1>
      <p class="lead">Don't keep your secrets, share them anonymously!</p>
      <hr>
      <a class="btn btn-light btn-lg" href="/register" role="button">Register</a>
      <a class="btn btn-dark btn-lg" href="/login" role="button">Login</a>

      <script>
        Swal.fire({
          html: "<div><h1>The Chamber of Secrets</h1><br><h3>Concept:</h3><br>A user after signing up by creating an ID & password or signing up through google can submit their deepest secret with the world and thus reduce their cognitive burden. Since their identity will not be linked with their secret, no one can actually know about which secret was submitted by whom. Apart from reducing the burden of secret sharers, this website also serves as a source of entertainment and fascination as people read other people's secrets.<br><br><h3>Technology:</h3><br>This website uses Node.js & Express.js for back-end and Embedded JavaScript templating (EJS) to create a consistent look across all the pages without repeating the header & footer code. MongoDB is used as a database to store all the secrets submitted by users and their login information. Now the main feature of this website... ðŸ˜ƒ Implementation of advanced security, in the sense, we know that many web developers store the passwords created by users while signing up in plain-text format in their database. This is very less secure as any hacker who gets access to this databse or any employee or partner of that website's owner can see the passwords, next option is to encrypt the passwords, after which even if someone gets into the database they will only get encrypted passwords! but this is also not good enough :( because if someone gets access to the main javascript file of the website, (which they can if they were able to get into the database) they can see the encryption key and thus decrypt all passwords found in the database with that key. So our next option is to hash the passwords, which means that a hash will be generated for each password and will be stored in the database instead of the password. Now as we know that we cannot decrypt a hash and go back to plaintext, there is no encryption key here. When the user logs in next time, their password is again converted to hash and matched with the stored password, if these two hashes match, the user logs in. This also means that even the website owner cannot see any user's password now and thus ensures that no hacker can access it. Or is it? Well, now hackers exploit the fact that the hash for a certain password always remains same. So what they do is create a hash-table, which means they map the hashes found in a database to the most common passwords, like we know that some most common passwords are '123456', 'password' etc. and with millions of passwords leaked already (from previous breaches) available on the internet, a hacker can easily create a large hash table. So now what we can do to tackle this problem is to do some 'salting'. Salting means to add a random text to the password before hashing thus every hash for the same password will be different. The random text is also stored along with the hash for each user in the database so that the user can still be authenticated next time. We can toughen this up by increasing the number of rounds of salting, so for example in two rounds of salting a random text will be added to the password, which will pass through the hashing algorithm, then again a random text will be added to that hash which will again pass through the hashing algorithm and so forth. <br><br>Coming to this site now, I have implemented ten rounds of salting and hashing of the passwords. I believe that the race between good guys & bad guys is an eternal one and therefore we now see some big security firms implementing something called 'peppering' with salting & more such advances now. <br><br> One of the easiest ways for small companies & developers to remain safe from hackers without spending too much resources on security is by outsourcing the handling of passwords to big firms like google and facebook who have high level of security. Therefore I have also given my users the option of google sign-in on my website. By this method, google verifies that the user is a legit member in their records & I don't have to store any hash or salt related to user. It is google's tension to secure the user's password (of user's google account) from hackers. I just take the basic info like the user's name etc. from google & start the user's session. I have achieved this through the use of OAuth 2.0 which is the de facto industry standard for online authorization and Passport.js which is also used here to create cookies & sessions so that the user can reopen the website and still can submit a secret without having to login again as long as he/she doesn't log out or the cookie created by the website in their browser doesn't expire.<br><br><h3>Aim of this project:</h3><br>The major aims of this project are:-<br>* To demonstrate the usage of OAUTH 2.0 and sign-in through google<br>* To demonstrate the usage of passport library to create cookies & sessions<br>* To demonstrate my understanding of advanced security concepts by implementing hashing and salting of passwords.<br><br>Note: Authentication is not required for viewing secrets, it is required so that each user can submit only one secret. (To avoid spamming)<br><br>-Aishwary Shukla</div><style>div {text-align: justify;text-justify: inter-word;}</style>",
          imageUrl: '/images/forest.jpg',
          width: 1100,
          padding: '3em',
          confirmButtonColor: '#3ad1f7',
          confirmButtonText: 'Cool',
          imageWidth: 1100,
          imageAlt: 'Forest image',
        });
      </script>
    </div>
  </div>

  <%- include('partials/footer') %>